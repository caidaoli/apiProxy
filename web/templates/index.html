<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>APIä»£ç†æœåŠ¡å™¨ - ç»Ÿè®¡é¢æ¿</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <link rel="stylesheet" href="/static/css/styles.css">
</head>
<body class="with-navbar">
    <!-- é¡¶éƒ¨å¯¼èˆªæ  -->
    <nav class="navbar">
        <div class="navbar-container">
            <a href="/" class="navbar-brand">
                <div class="navbar-logo">P</div>
                <span class="navbar-title">API Proxy</span>
            </a>
            <div class="navbar-nav">
                <a href="/" class="nav-item active">
                    <span>ğŸ“Š</span>
                    <span>ç»Ÿè®¡æ¦‚è§ˆ</span>
                </a>
                <a href="/admin" class="nav-item">
                    <span>ğŸ”§</span>
                    <span>æ˜ å°„ç®¡ç†</span>
                </a>
            </div>
        </div>
    </nav>

    <div class="container">
        <div class="chart-section">
            <div class="chart-header">
                <h2 class="chart-title">ğŸ“Š APIè°ƒç”¨ç»Ÿè®¡å›¾è¡¨</h2>
                <div class="chart-controls">
                    <div class="endpoint-selector">
                        <label for="endpointSelect">é€‰æ‹©ç«¯ç‚¹ï¼š</label>
                        <select id="endpointSelect" class="endpoint-select">
                            <option value="all">å…¨éƒ¨ç«¯ç‚¹</option>
                        </select>
                    </div>
                    <div class="time-tabs">
                        <button class="time-tab active" data-period="today">24å°æ—¶</button>
                        <button class="time-tab" data-period="week">7å¤©</button>
                        <button class="time-tab" data-period="month">30å¤©</button>
                        <button class="time-tab" data-period="total">æ€»è®¡</button>
                    </div>
                </div>
            </div>
            <div class="chart-info">
                <p id="chartInfoText">ğŸ“Š ç»„åˆå›¾è¡¨ï¼šè“è‰²æŸ±çŠ¶å›¾æ˜¾ç¤ºæ€»APIè°ƒç”¨æ¬¡æ•°ï¼Œçº¢è‰²æŠ˜çº¿å›¾æ˜¾ç¤ºæ€»ä½“è°ƒç”¨è¶‹åŠ¿ã€‚é€‰æ‹©ä¸Šæ–¹æ—¶é—´èŒƒå›´æŸ¥çœ‹ä¸åŒç»´åº¦æ•°æ®ã€‚</p>
            </div>
            <div class="chart-container-wrapper">
                <div class="chart-container">
                    <canvas id="apiChart"></canvas>
                </div>
            </div>
        </div>
        
        <div class="stats-grid" id="stats-grid">
            <!-- ç»Ÿè®¡å¡ç‰‡å°†é€šè¿‡JavaScriptåŠ¨æ€åŠ è½½ -->
        </div>
        
        <div class="usage-guide">
            <h2>ğŸ“– ä½¿ç”¨è¯´æ˜</h2>
            <h3>æ”¯æŒçš„APIç«¯ç‚¹</h3>
            <div class="endpoint-list" id="endpoint-list">
                <!-- ç«¯ç‚¹åˆ—è¡¨å°†é€šè¿‡JavaScriptåŠ¨æ€åŠ è½½ -->
            </div>
            
            <div class="example-section">
                <h3>ğŸ”§ ä½¿ç”¨æ–¹æ³•</h3>
                <p style="margin-bottom: 16px; color: #666;">å°†åŸå§‹APIåœ°å€æ›¿æ¢ä¸ºä»£ç†åœ°å€ï¼Œä¾‹å¦‚ï¼š</p>
                
                <h4 style="margin: 16px 0 8px 0; color: #333;">OpenAI API ç¤ºä¾‹ï¼š</h4>
                <div class="code-block"># åŸå§‹åœ°å€
https://api.openai.com/v1/chat/completions

# ä»£ç†åœ°å€
<span id="current-domain">loading...</span>/openai/v1/chat/completions</div>
                
                <h4 style="margin: 16px 0 8px 0; color: #333;">JavaScript ç¤ºä¾‹ï¼š</h4>
                <div class="code-block">// ä½¿ç”¨ fetch API
const response = await fetch('<span id="js-example-domain">loading...</span>/openai/v1/chat/completions', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer YOUR_API_KEY'
  },
  body: JSON.stringify({
    model: 'gpt-3.5-turbo',
    messages: [{ role: 'user', content: 'Hello!' }]
  })
});

const data = await response.json();
console.log(data);</div>
                
                <h4 style="margin: 16px 0 8px 0; color: #333;">Gemini API ç¤ºä¾‹ï¼š</h4>
                <div class="code-block"># åŸå§‹åœ°å€
https://generativelanguage.googleapis.com/v1/models

# ä»£ç†åœ°å€
<span id="gemini-example-domain">loading...</span>/gemini/v1/models</div>
                
                <h4 style="margin: 16px 0 8px 0; color: #333;">Claude API ç¤ºä¾‹ï¼š</h4>
                <div class="code-block"># åŸå§‹åœ°å€
https://api.anthropic.com/v1/messages

# ä»£ç†åœ°å€
<span id="claude-example-domain">loading...</span>/claude/v1/messages</div>
            </div>
            
            <div class="example-section">
                <h3>âš¡ é€æ˜ä»£ç†ç‰¹æ€§</h3>
                <ul style="margin-left: 20px; color: #666; line-height: 1.6;">
                    <li>âœ… æ”¯æŒæ‰€æœ‰HTTPæ–¹æ³• (GET, POST, PUT, DELETEç­‰)</li>
                    <li>âœ… å®Œå…¨é€æ˜è½¬å‘è¯·æ±‚å¤´å’Œå“åº”å¤´(ç¬¦åˆRFC 7230)</li>
                    <li>âœ… ä¸ä¿®æ”¹è¯·æ±‚å’Œå“åº”å†…å®¹,ä¿æŒåŸæ ·</li>
                    <li>âœ… æ”¯æŒCORSè·¨åŸŸè¯·æ±‚</li>
                    <li>âœ… å®æ—¶ç»Ÿè®¡APIè°ƒç”¨æ¬¡æ•°</li>
                    <li>âœ… è‡ªåŠ¨è·å–å½“å‰åŸŸåï¼Œæ— éœ€æ‰‹åŠ¨é…ç½®</li>
                    <li>âœ… ç»„åˆå›¾è¡¨å±•ç¤ºè°ƒç”¨ç»Ÿè®¡å’Œè¶‹åŠ¿</li>
                </ul>
            </div>
            
          
            
        
        </div>
    </div>
    <button class="refresh-btn" onclick="refreshData()">ğŸ”„ åˆ·æ–°æ•°æ®</button>
    
    <div id="toast" class="toast"></div>
    
    <script>
        let rawStatsData = null;
        let chartInstance = null;
        let currentPeriod = 'today';
        let currentEndpoint = 'all';
        let currentDomain = '';
        let apiMapping = {}; // åŠ¨æ€åŠ è½½çš„APIæ˜ å°„
        const barColors = ['#6366f1', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#06b6d4', '#84cc16', '#f97316', '#ec4899', '#64748b', '#14b8a6', '#a855f7', '#eab308', '#22c55e', '#3b82f6'];

        // è·å–å½“å‰åŸŸå
        function getCurrentDomain() {
            const protocol = window.location.protocol;
            const host = window.location.host;
            return `${protocol}//${host}`;
        }

        // åŠ è½½APIæ˜ å°„é…ç½®
        async function loadAPIMappings() {
            try {
                const response = await fetch('/api/public/mappings');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                if (data.success && data.mappings) {
                    apiMapping = data.mappings;
                    console.log('âœ… å·²ä»æœåŠ¡å™¨åŠ è½½', data.count, 'ä¸ªAPIæ˜ å°„');
                } else {
                    console.warn('âš ï¸ æœªèƒ½åŠ è½½APIæ˜ å°„æ•°æ®');
                }
            } catch (error) {
                console.error('åŠ è½½APIæ˜ å°„å¤±è´¥:', error);
                showToast('åŠ è½½APIæ˜ å°„å¤±è´¥,è¯·åˆ·æ–°é¡µé¢é‡è¯•');
            }
        }

        // åŠ è½½ç»Ÿè®¡æ•°æ®
        async function loadStatsData() {
            try {
                const response = await fetch('/stats');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                
                rawStatsData = {
                    stats: {
                        total: data.total,
                        endpoints: data.endpoints
                    },
                    performance: data.performance,
                    requests: data.requests || [], // ä»åç«¯è·å–çš„è¯·æ±‚æ—¶é—´æˆ³æ•°æ®
                    endpoints: data.endpoints
                };
                
                return data;
            } catch (error) {
                console.error('åŠ è½½ç»Ÿè®¡æ•°æ®å¤±è´¥:', error);
                showToast('åŠ è½½æ•°æ®å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•');
                return null;
            }
        }

        // æ¸²æŸ“ç»Ÿè®¡å¡ç‰‡
        function renderStatsCards(data) {
            const activeEndpoints = Object.keys(data.endpoints || {}).filter(k =>
                data.endpoints[k].total > 0
            ).length;

            // æ€§èƒ½ç­‰çº§CSSç±»
            const getPerformanceClass = (value, good, warning) => {
                if (value <= good) return 'good';
                if (value <= warning) return 'warning';
                return 'danger';
            };

            const getMemoryClass = (value) => {
                if (value <= 50) return 'good';
                if (value <= 100) return 'warning';
                return 'danger';
            };

            const getResponseTimeClass = (value) => {
                if (value <= 100) return 'good';
                if (value <= 500) return 'warning';
                return 'danger';
            };

            const getErrorRateClass = (value) => {
                if (value <= 1.0) return 'good';
                if (value <= 5.0) return 'warning';
                return 'danger';
            };

            const performance = data.performance || {};
            const qpsClass = getPerformanceClass(performance.requests_per_sec || 0, 10, 50);
            const responseTimeClass = getResponseTimeClass(performance.avg_response_time_ms || 0);
            const errorRateClass = getErrorRateClass(performance.error_rate || 0);
            const memoryClass = getMemoryClass(performance.memory_usage_mb || 0);

            document.getElementById('stats-grid').innerHTML = `
                <div class="stat-card">
                    <h3><div class="api-icon total-icon">ğŸ“Š</div>æ€»ä½“ç»Ÿè®¡</h3>
                    <div class="stat-row"><span class="stat-label">æ€»è¯·æ±‚æ•°</span><span class="stat-value">${data.total || 0}</span></div>
                    <div class="stat-row"><span class="stat-label">æ´»è·ƒç«¯ç‚¹</span><span class="stat-value">${activeEndpoints}</span></div>
                    <div class="stat-row"><span class="stat-label">æœåŠ¡çŠ¶æ€</span><span class="stat-value good">ğŸŸ¢ è¿è¡Œä¸­ (Goä¼˜åŒ–ç‰ˆ)</span></div>
                </div>
                <div class="stat-card">
                    <h3><div class="api-icon perf-icon">âš¡</div>å®æ—¶æ€§èƒ½æŒ‡æ ‡</h3>
                    <div class="stat-row"><span class="stat-label">æ¯ç§’è¯·æ±‚æ•°</span><span class="stat-value ${qpsClass}">${(performance.requests_per_sec || 0).toFixed(2)} QPS</span></div>
                    <div class="stat-row"><span class="stat-label">å¹³å‡å“åº”æ—¶é—´</span><span class="stat-value ${responseTimeClass}">${performance.avg_response_time_ms || 0} ms</span></div>
                    <div class="stat-row"><span class="stat-label">é”™è¯¯ç‡</span><span class="stat-value ${errorRateClass}">${(performance.error_rate || 0).toFixed(2)}%</span></div>
                    <div class="stat-row"><span class="stat-label">å†…å­˜ä½¿ç”¨</span><span class="stat-value ${memoryClass}">${(performance.memory_usage_mb || 0).toFixed(2)} MB</span></div>
                    <div class="stat-row"><span class="stat-label">åç¨‹æ•°é‡</span><span class="stat-value">${performance.goroutine_count || 0}</span></div>
                </div>
            `;
        }

        // æ¸²æŸ“ç«¯ç‚¹åˆ—è¡¨
        function renderEndpointList() {
            let endpointListHTML = '';

            // è·å–æœ‰æ•°æ®çš„ç«¯ç‚¹å¹¶æŒ‰è°ƒç”¨æ¬¡æ•°æ’åºï¼Œå–å‰8ä¸ª
            if (rawStatsData && rawStatsData.endpoints && Object.keys(rawStatsData.endpoints).length > 0) {
                const activeEndpoints = Object.keys(rawStatsData.endpoints)
                    .filter(ep => rawStatsData.endpoints[ep].total > 0)
                    .sort((a, b) => rawStatsData.endpoints[b].total - rawStatsData.endpoints[a].total)
                    .slice(0, 8);

                // å¦‚æœæœ‰æ´»è·ƒç«¯ç‚¹ï¼Œæ˜¾ç¤ºæ´»è·ƒç«¯ç‚¹ï¼›å¦åˆ™æ˜¾ç¤ºæ‰€æœ‰æ˜ å°„çš„ç«¯ç‚¹
                if (activeEndpoints.length > 0) {
                    activeEndpoints.forEach(endpoint => {
                        endpointListHTML += `<div class="endpoint-item" title="ç‚¹å‡»å¤åˆ¶å®Œæ•´åœ°å€">
                            <div class="endpoint-path">${endpoint}</div>
                            <div class="endpoint-url">${currentDomain}${endpoint}</div>
                        </div>`;
                    });
                } else {
                    // æœ‰ç»Ÿè®¡æ•°æ®ä½†æ²¡æœ‰æ´»è·ƒç«¯ç‚¹ï¼Œæ˜¾ç¤ºæ‰€æœ‰æ˜ å°„çš„ç«¯ç‚¹
                    const endpoints = Object.keys(apiMapping).slice(0, 8);
                    endpoints.forEach(endpoint => {
                        endpointListHTML += `<div class="endpoint-item" title="ç‚¹å‡»å¤åˆ¶å®Œæ•´åœ°å€">
                            <div class="endpoint-path">${endpoint}</div>
                            <div class="endpoint-url">${currentDomain}${endpoint}</div>
                        </div>`;
                    });
                }
            } else {
                // å¦‚æœæ²¡æœ‰ç»Ÿè®¡æ•°æ®ï¼Œæ˜¾ç¤ºæ‰€æœ‰ç«¯ç‚¹ï¼ˆå‰8ä¸ªï¼‰
                const endpoints = Object.keys(apiMapping).slice(0, 8);
                endpoints.forEach(endpoint => {
                    endpointListHTML += `<div class="endpoint-item" title="ç‚¹å‡»å¤åˆ¶å®Œæ•´åœ°å€">
                        <div class="endpoint-path">${endpoint}</div>
                        <div class="endpoint-url">${currentDomain}${endpoint}</div>
                    </div>`;
                });
            }

            document.getElementById('endpoint-list').innerHTML = endpointListHTML;

            // æ·»åŠ ç‚¹å‡»å¤åˆ¶åŠŸèƒ½
            document.querySelectorAll('.endpoint-item').forEach(item => {
                item.addEventListener('click', function() {
                    const url = this.querySelector('.endpoint-url').textContent.trim();
                    copyToClipboard(url);
                    const originalBg = this.style.backgroundColor;
                    const originalBorder = this.style.borderLeftColor;
                    this.style.backgroundColor = '#dcfce7';
                    this.style.borderLeftColor = '#16a34a';
                    setTimeout(() => {
                        this.style.backgroundColor = originalBg;
                        this.style.borderLeftColor = originalBorder;
                    }, 1000);
                });
            });
        }

     

        // æ›´æ–°åŸŸåç›¸å…³çš„æ˜¾ç¤º
        function updateDomainReferences() {
            document.getElementById('current-domain').textContent = currentDomain;
            document.getElementById('js-example-domain').textContent = currentDomain;
            document.getElementById('gemini-example-domain').textContent = currentDomain;
            document.getElementById('claude-example-domain').textContent = currentDomain;
        }

        // å›¾è¡¨ç›¸å…³å‡½æ•°
        function getChartDataForPeriod(period, allRequests, endpointDetails, selectedEndpoint = 'all') {
            const now = Date.now();
            let labels = [];
            let aggregatedData = [];

            // æ ¹æ®é€‰æ‹©çš„ç«¯ç‚¹è¿‡æ»¤è¯·æ±‚
            let filteredRequests = allRequests;
            if (selectedEndpoint !== 'all') {
                filteredRequests = allRequests.filter(req => req.endpoint === selectedEndpoint);
            }

            if (period === 'today') {
                const hourlyCounts = Array(24).fill(0);
                const firstHourTimestamp = new Date(now - 23 * 60 * 60 * 1000);
                firstHourTimestamp.setMinutes(0, 0, 0);

                for (let i = 0; i < 24; i++) {
                    const hour = new Date(firstHourTimestamp);
                    hour.setHours(firstHourTimestamp.getHours() + i);
                    labels.push(hour.getHours().toString().padStart(2, '0') + ':00');
                }

                const twentyFourHoursAgo = now - 24 * 60 * 60 * 1000;
                filteredRequests.filter(req => (req.timestamp * 1000) >= twentyFourHoursAgo)
                    .forEach(req => {
                        const reqHour = new Date(req.timestamp * 1000);
                        const diffHours = Math.floor((reqHour.getTime() - firstHourTimestamp.getTime()) / (60 * 60 * 1000));
                        if (diffHours >= 0 && diffHours < 24) {
                            hourlyCounts[diffHours]++;
                        }
                    });
                aggregatedData = hourlyCounts;
            } else if (period === 'week' || period === 'month') {
                const numDays = period === 'week' ? 7 : 30;
                const dailyCounts = Array(numDays).fill(0);
                const firstDayTimestamp = new Date(now);
                firstDayTimestamp.setDate(firstDayTimestamp.getDate() - (numDays - 1));
                firstDayTimestamp.setHours(0, 0, 0, 0);

                for (let i = 0; i < numDays; i++) {
                    const day = new Date(firstDayTimestamp);
                    day.setDate(firstDayTimestamp.getDate() + i);
                    labels.push(day.getFullYear() + '-' + (day.getMonth() + 1).toString().padStart(2, '0') + '-' + day.getDate().toString().padStart(2, '0'));
                }

                const periodStartTimestamp = firstDayTimestamp.getTime();
                filteredRequests.filter(req => (req.timestamp * 1000) >= periodStartTimestamp)
                    .forEach(req => {
                        const reqDay = new Date(req.timestamp * 1000);
                        reqDay.setHours(0,0,0,0);
                        const diffDays = Math.floor((reqDay.getTime() - firstDayTimestamp.getTime()) / (24 * 60 * 60 * 1000));
                        if (diffDays >= 0 && diffDays < numDays) {
                           dailyCounts[diffDays]++;
                        }
                    });
                aggregatedData = dailyCounts;
            } else if (period === 'total') {
                if (selectedEndpoint === 'all') {
                    const activeEndpoints = Object.keys(endpointDetails).filter(ep => endpointDetails[ep].total > 0);
                    labels = activeEndpoints.map(ep => ep.replace('/', ''));
                    aggregatedData = activeEndpoints.map(ep => endpointDetails[ep].total);
                } else {
                    // å¯¹äºç‰¹å®šç«¯ç‚¹ï¼Œæ˜¾ç¤ºä¸åŒæ—¶é—´æ®µçš„æ•°æ®
                    labels = ['24å°æ—¶', '7å¤©', '30å¤©', 'æ€»è®¡'];
                    const stats = endpointDetails[selectedEndpoint] || { today: 0, week: 0, month: 0, total: 0 };
                    aggregatedData = [stats.today, stats.week, stats.month, stats.total];
                }
            }
            return { labels, data: aggregatedData };
        }

        function createCombinedChart(period) {
            const ctx = document.getElementById('apiChart').getContext('2d');
            if (chartInstance) chartInstance.destroy();

            const chartData = getChartDataForPeriod(period, rawStatsData.requests || [], rawStatsData.endpoints || {}, currentEndpoint);

            if (chartData.labels.length === 0) {
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                ctx.fillStyle = '#64748b';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('æš‚æ— æ•°æ®', ctx.canvas.width / 2, ctx.canvas.height / 2);
                updateChartInfo();
                return;
            }

            const xAxisTitle = period === 'total'
                ? (currentEndpoint === 'all' ? 'API ç«¯ç‚¹' : 'æ—¶é—´æ®µ')
                : (period === 'today' ? 'å°æ—¶ (è¿‡å»24å°æ—¶)' : 'æ—¥æœŸ');

            const chartConfig = {
                type: 'bar',
                data: {
                    labels: chartData.labels,
                    datasets: [
                        {
                            type: 'bar',
                            label: 'APIè°ƒç”¨æ¬¡æ•°',
                            data: chartData.data,
                            backgroundColor: period === 'total' 
                                ? chartData.labels.map((_, i) => barColors[i % barColors.length] + 'B3')
                                : '#6366f1B3',
                            borderColor: period === 'total' 
                                ? chartData.labels.map((_, i) => barColors[i % barColors.length])
                                : '#6366f1',
                            borderWidth: 1.5,
                            yAxisID: 'y',
                            order: 2
                        },
                        {
                            type: 'line',
                            label: 'è°ƒç”¨è¶‹åŠ¿',
                            data: chartData.data,
                            borderColor: '#ef4444',
                            backgroundColor: 'rgba(239, 68, 68, 0.1)',
                            borderWidth: 2.5,
                            pointBackgroundColor: '#ef4444',
                            pointBorderColor: 'white',
                            pointBorderWidth: 1.5,
                            pointRadius: period === 'total' ? 4 : (period === 'today' ? 3 : 4),
                            pointHoverRadius: period === 'total' ? 6 : (period === 'today' ? 5 : 6),
                            fill: false,
                            tension: (period === 'today' || period === 'total') ? 0.1 : 0.3,
                            yAxisID: 'y',
                            order: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    plugins: {
                        legend: { display: true, position: 'top', labels: { usePointStyle: true, padding: 20, font: { size: 12 } } },
                        tooltip: {
                            backgroundColor: 'rgba(0,0,0,0.85)',
                            titleColor: 'white',
                            bodyColor: 'white',
                            borderColor: '#6366f1',
                            borderWidth: 1,
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) label += ': ';
                                    if (context.parsed.y !== null) label += context.parsed.y + ' æ¬¡';
                                    
                                    if (period === 'total') {
                                        const total = chartData.data.reduce((a, b) => a + b, 0);
                                        if (total > 0) {
                                            const percentage = ((context.raw / total) * 100).toFixed(1);
                                            label += ' (' + percentage + '%)';
                                        }
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: xAxisTitle, color: '#333', font: { weight: 'bold' } },
                            ticks: { color: '#64748b', maxRotation: period === 'month' ? 45 : 0, minRotation: 0 },
                            grid: { color: '#e2e8f0' }
                        },
                        y: {
                            beginAtZero: true,
                            ticks: { color: '#64748b', precision: 0 },
                            grid: { color: '#e2e8f0' },
                            title: { display: true, text: 'è°ƒç”¨æ¬¡æ•°', color: '#333', font: { weight: 'bold' } }
                        }
                    },
                    animation: { duration: 800, easing: 'easeOutQuart' }
                }
            };
            chartInstance = new Chart(ctx, chartConfig);
            updateChartInfo();
        }

        function updateChartInfo() {
            const infoElement = document.getElementById('chartInfoText');
            if (currentEndpoint === 'all') {
                infoElement.textContent = 'ğŸ“Š ç»„åˆå›¾è¡¨ï¼šè“è‰²æŸ±çŠ¶å›¾æ˜¾ç¤ºæ€»APIè°ƒç”¨æ¬¡æ•°ï¼Œçº¢è‰²æŠ˜çº¿å›¾æ˜¾ç¤ºæ€»ä½“è°ƒç”¨è¶‹åŠ¿ã€‚é€‰æ‹©ä¸Šæ–¹æ—¶é—´èŒƒå›´æŸ¥çœ‹ä¸åŒç»´åº¦æ•°æ®ã€‚';
            } else {
                const endpointName = currentEndpoint.replace('/', '');
                infoElement.textContent = `ğŸ“Š ç»„åˆå›¾è¡¨ï¼šæ˜¾ç¤º ${endpointName} ç«¯ç‚¹çš„è°ƒç”¨ç»Ÿè®¡ã€‚è“è‰²æŸ±çŠ¶å›¾æ˜¾ç¤ºè°ƒç”¨æ¬¡æ•°ï¼Œçº¢è‰²æŠ˜çº¿å›¾æ˜¾ç¤ºè°ƒç”¨è¶‹åŠ¿ã€‚`;
            }
        }

        // å¡«å……ç«¯ç‚¹é€‰æ‹©å™¨
        function populateEndpointSelector() {
            const selector = document.getElementById('endpointSelect');
            selector.innerHTML = '<option value="all">å…¨éƒ¨ç«¯ç‚¹</option>';

            if (rawStatsData && rawStatsData.endpoints) {
                const activeEndpoints = Object.keys(rawStatsData.endpoints)
                    .filter(ep => rawStatsData.endpoints[ep].total > 0)
                    .sort();

                activeEndpoints.forEach(endpoint => {
                    const option = document.createElement('option');
                    option.value = endpoint;
                    option.textContent = endpoint.replace('/', '') + ' (' + rawStatsData.endpoints[endpoint].total + 'æ¬¡)';
                    selector.appendChild(option);
                });
            }
        }

        // åˆ‡æ¢ç«¯ç‚¹
        function switchEndpoint(newEndpoint) {
            currentEndpoint = newEndpoint;
            document.getElementById('endpointSelect').value = newEndpoint;
            createCombinedChart(currentPeriod);
        }


        function switchPeriod(newPeriod) {
            currentPeriod = newPeriod;
            document.querySelectorAll('.time-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelector('[data-period="' + newPeriod + '"]').classList.add('active');
            createCombinedChart(currentPeriod);
        }

        // å·¥å…·å‡½æ•°
        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        function copyToClipboard(text) {
            if (navigator.clipboard) {
                navigator.clipboard.writeText(text).then(() => {
                    showToast('å·²å¤åˆ¶: ' + text);
                }, () => {
                    fallbackCopy(text);
                });
            } else {
                fallbackCopy(text);
            }
        }

        function fallbackCopy(text) {
            const ta = document.createElement('textarea');
            ta.value = text;
            document.body.appendChild(ta);
            ta.select();
            try {
                document.execCommand('copy');
                showToast('å·²å¤åˆ¶: ' + text);
            } catch (err) {
                showToast('å¤åˆ¶å¤±è´¥');
            }
            document.body.removeChild(ta);
        }

        // åˆ·æ–°æ•°æ®
        async function refreshData() {
            const data = await loadStatsData();
            if (data) {
                renderStatsCards(data);
                populateEndpointSelector();
                renderEndpointList();
                createCombinedChart(currentPeriod);
                showToast('æ•°æ®å·²åˆ·æ–°');
            }
        }

        // é¡µé¢åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', async function() {
            currentDomain = getCurrentDomain();
            updateDomainReferences();

            // å…ˆåŠ è½½APIæ˜ å°„é…ç½®
            await loadAPIMappings();

            // å†åŠ è½½ç»Ÿè®¡æ•°æ®
            const data = await loadStatsData();
            if (data) {
                renderStatsCards(data);
                populateEndpointSelector();
                renderEndpointList();
                createCombinedChart(currentPeriod);
            }

            // æ—¶é—´åˆ‡æ¢æŒ‰é’®äº‹ä»¶
            document.querySelectorAll('.time-tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    switchPeriod(this.dataset.period);
                });
            });

            // ç«¯ç‚¹é€‰æ‹©å™¨äº‹ä»¶
            document.getElementById('endpointSelect').addEventListener('change', function() {
                switchEndpoint(this.value);
            });
        });

        // å®šæ—¶åˆ·æ–°
        setInterval(refreshData, 60000);
    </script>
</body>
</html>
